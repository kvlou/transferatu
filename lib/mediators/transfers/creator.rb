module Transferatu
  module Mediators::Transfers
    class InvalidTransferError < StandardError; end

    class Creator < Mediators::Base
      def initialize(group:,
                     from_type:, from_url:, from_name: nil,
                     to_type:, to_url:, to_name: nil,
                     from_bastion_host: nil, from_bastion_key: nil,
                     to_bastion_host: nil, to_bastion_key: nil,
                     options:, schedule: nil, num_keep: nil)
        @group = group
        @from_type = from_type
        @from_url = from_url
        @from_name = from_name
        @to_type = to_type
        @to_url = to_url
        @to_name = to_name
        @from_bastion_host = from_bastion_host
        @from_bastion_key = from_bastion_key
        @to_bastion_host = to_bastion_host
        @to_bastion_key = to_bastion_key
        @options = options
        @schedule = schedule
        @num_keep = num_keep
      end

      def call
        if !@schedule.nil? && @group.uuid != @schedule.group.uuid
          raise InvalidTransferError, "schedule group must match transfer group"
        end

        # TODO: this is a really crufty way to handle autogenerated URLs
        if @to_type == 'gof3r'
          if !@group.backup_limit.nil? && @group.active_backups.count >= @group.backup_limit && @schedule.nil?
            raise InvalidTransferError, "too many active backups for group; delete one before capturing another"
          end
          if @to_url == 'auto'
            bucket = Config.s3_bucket_name
            key = "#{URI.encode(@group.name)}/#{Time.new.utc.iso8601}/#{SecureRandom.uuid}"
            @to_url = "https://#{bucket}.s3.amazonaws.com/#{key}"
          else
            raise InvalidTransferError, "to_url must be 'auto' for transfers targeting gof3r"
          end
        end
        if @to_type == 'pg_restore'
          begin
            to_uri = URI.parse(@to_url)
            if to_uri.scheme.nil? || to_uri.scheme != 'postgres'
              raise InvalidTransferError, "to_url must be valid postgres URL for pg_restore"
            end
          rescue URI::InvalidURIError
            raise InvalidTransferError, "invalid to_url for pg_restore"
          end
        end
        if @from_type == 'pg_dump'
          begin
            from_uri = URI.parse(@from_url)
            if from_uri.scheme.nil? || from_uri.scheme != 'postgres'
              raise InvalidTransferError, "from_url must be valid postgres URL for pg_dump"
            end
          rescue URI::InvalidURIError
            raise InvalidTransferError, "invalid from_url for pg_dump"
          end
        end
        # hack: gopher can't deal with public signed S3 URLs or other
        # sources; we just rewrite here to make it easy on the clients
        if @from_type == 'gof3r' && !internal_url?(@from_url)
          @from_type = 'htcat'
        end
        begin
          create_opts = { group: @group,
                          from_type: @from_type, from_url: @from_url, from_name: @from_name,
                          to_type: @to_type, to_url: @to_url, to_name: @to_name,
                          from_bastion_host: @from_bastion_host, from_bastion_key: @from_bastion_key,
                          to_bastion_host: @to_bastion_host, to_bastion_key: @to_bastion_key,
                          options: @options, schedule: @schedule }
          unless @num_keep.nil?
            create_opts[:num_keep] = @num_keep
          end
          Transfer.create(create_opts)
        rescue StandardError => e
          puts e.inspect
        end
      end

      private

      def internal_url?(url)
        url =~ %r{\Ahttps://#{Config.s3_bucket_name}.s3.amazonaws.com}
      end
    end
  end
end
